Аннотация @Repository помечает класс как сущность, которая используется для работы с БД
По сути тот же @Component, но при этом обрабатывает исключения специфичные для БД, в понятные для Spring.

@Transactional аннотация используется для пометки, что метод должен выполняться в рамках транзакции
**ВАЖНО** если вызывающий метод не помечен аннотацией, и при этом он внутри себя вызывает метод, который помечен аннотацией, то по сути транзакции не создается, потому что в Spring используется проксирование объектов, и по сути, при вызове метода внутри мы не будем знать об этой аннотации, так как вызываем через прокси объект

У аннотации есть два параметра
- propagation - определяет, что делать если вызывающий метод и вызываемый метод оба имею аннотации @Transactional
		- REQUIRED: выполняем в текущей или создаем новую
		- REQUIRES_NEW: всегда создаем новую, старую останавливаем
		- SUPPORTS: если транзакция есть, выполняем в ней, если нет, выполняем без нее
		- NOT_SUPPORTS: если есть транзакция, останавливаем и выполняем без
		- MANDATORY: если нет транзакции то кидаем исключение, без нее не выполняем
		- NEVER: если есть транзакция кидаем исключение, выполняем только без нее
		- NESTED: создание вложенной транзакции
- isolation
		- DEFAULT: используем уровень установленный в БД
		- READ_UNCOMMITED: позволяет читать несохраненные изменения
		- READ_COMMITED: читаем только сохраненные изменения
		- REPEATABLE_RED: гарантирует неизменяемость данных при чтении в транзакции (но остается проблема фантомных записей)
		- SERIALIZABLE: работаем с данными в полной изоляции