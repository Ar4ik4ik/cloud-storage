---
создал заметку: "2025-08-31"
---
Когда пользователь отправляет запрос на сервер, первое с чем работает сервер это идентификация клиента по его идентификатору, затем происходит аутентификация, то есть проверка подлинности тех данных, которые передает клиент, с теми, которые сервер получает по переданному идентификатору, при этом, в качестве пароля может использоваться любая сущность, токен, смс-код и т.д

В Spring Security процесс аутентификации построен на фильтрах, так как, прежде чем запрос попадет в dispatcher servlet, он будет обработан фильтрами, это могут быть фильтры модифицирующие запрос, и фильтры аутентифицирующие запрос, про что и идет речь

### Авторизация при помощи Basic Authentication

```plantuml
autonumber
actor User
box Application
	participant "Spring Security"
	participant "Spring Framework\nDispatcher Servlet"
end box

User -> "Spring Security": <b>GET http://localhost:8080/hello.html
"Spring Security" -> "Spring Security": Пользователь не\nаутентифицирован
"Spring Security" --> User: <b>401 Unauthorized\nWWW-Authenticate: Basic Realm="my realm"
User -> "Spring Security": <b>GET http://localhost:8080/hello.html\nAuthorization: Basic ...
"Spring Security" -> "Spring Security": Аутентификация пользователя
"Spring Security" -> "Spring Framework\nDispatcher Servlet":<b>GET http://localhost:8080/hello.html\nAuthorization: Basic ...
"Spring Framework\nDispatcher Servlet" --> "Spring Security": <b> 200 OK\nContent-type: text/html\n<h1>Hello</h1>
"Spring Security" --> User: <b> 200 OK\nContent-type: text/html\n<h1>Hello</h1>

```

Basic аутентификация стандарт для HTTP, как правило используется в корп. решениях, пользователи редко сталкиваются с таким типом аутентификации. По сути этот тип ориентирован для stateless систем, которые не хранят данные о пользователе между запросами. При такой авторизации в текущий момент, после первой успешной попытки авторизоваться, браузер больше не будет предлагать пользователю ввести логин и пароль, потому что браузеры адаптированы под этот тип аутентификации, то есть, браузер запоминает введенные данные и использует их при последующем обращении до окончании сессии браузера

### Авторизация при помощи login form

```plantuml
autonumber
actor User
box Application
	participant "Spring Security"
	participant "Spring Framework\nDispatcher Servlet"
end box

User -> "Spring Security": <b>GET http://localhost:8080/hello.html
"Spring Security" -> "Spring Security": Пользователь не\nаутентифицирован
"Spring Security" --> User: <b>302 Found\nLocation: http://location:8080/login\nSet-Cookie: jSESSIONID=1
User -> "Spring Security": <b>POST http://localhost:8080/login\nContent-Type: application/x-www-form-urlencoded\n\nusername=user&password=password
"Spring Security" -> "Spring Security": Аутентификация\nпользователя
"Spring Security" --> User: <b>302 Found\nLocation: http://location:8080/hello.html?continue\nSet-Cookie: jSESSIONID=2
User -> "Spring Security": <b>GET http://localhost:8080/hello.html\nCookie: jSESSIONID=2
"Spring Security" -> "Spring Security": Получение пользовательской сессии
"Spring Security" -> "Spring Framework\nDispatcher Servlet":<b>GET http://localhost:8080/hello.html
"Spring Framework\nDispatcher Servlet" --> "Spring Security": <b> 200 OK\nContent-type: text/html\n<h1>Hello</h1>
"Spring Security" --> User: <b> 200 OK\nContent-type: text/html\n<h1>Hello</h1>


```

Тут можно заметить, что используются две куки, первая используется до аутентификации, то есть сообщается, что пользователь анонимный, а вторая после аутентификации, с уже конкретным пользователем в рамках сессии, но это можно поменять в настройках Spring Security
Также, вопрос с редиректами тоже конфигурируемый, то есть, что при перенаправлении пользователя на /login, что при перенаправлении после успешной аутентификации, это можно настраивать

### Что происходит в Spring Security?

```plantuml

autonumber

Filter -> Filter: Формирование запроса\nаутентификации\n(Authentication)
Filter -> AuthenticationManager: authenticate(Authentication)
AuthenticationManager -> AuthenticationProvider: authenticate(Authentication)
AuthenticationProvider -> UserDetailsService: loadUserByUsername(username)
UserDetailsService --> AuthenticationProvider: UserDetails
AuthenticationProvider -> AuthenticationProvider: Обработка запроса\nаутентификации
AuthenticationProvider --> AuthenticationManager: Authentication
AuthenticationManager --> Filter: Authentication
Filter -> Filter: Сохранение результата\nаутентификации в контексте\nбезопасности
```

Первый компонент который встречает запрос - это фильтр, задача фильтра извлечь из запроса информацию необходимую для инициализации процесса аутентификации и формирование запроса на аутентификацию
В зависимости от реализации, к примеру Basic Authentication, необходимо найти заголовок Authorization, извлечь значение, убедиться что это basic, полученную строку декодировать из base64

Основная реализация AuthenticationManager это ProviderManager, который опирается на список AuthenticationProvider, то есть, сам не аутентифицирует, а ищет провайдера и передает ему запрос аутентификации, но может выполнять дополнительные действия (логирование, ивенты и тд, также стирает секретные данные, если они есть и это требуется)

Так сделано, потому что на проекте может быть несколько типов аутентификации, а также проще расширять

В рамках системы, один и тот же тип аутентификации может обрабатываться несколькими провайдерами, сделано это может быть для того, чтобы, в случае если один провайдер по какой то причине не может обработать запрос на аутентификацию, а второй может, к примеру, две базы данных пользователей

Запрос и результат аутентификации чаще всего выражается одним типом объекта, но бывает и по другому, когда они разных классов

Всегда возвращаются разные экземпляры классов Authentication

### Способы получения информации о пользователе

Получение информации о пользователе - Spring Security в деталях


1. Получение через SecurityContextHolder
	• Использование SecurityContextHolder для получения UserDetails.
	• Пример получения имени пользователя через getPrincipal.
2. Получение через Request
	• Обращение к Request для получения UserDetails.
	• Интерфейс Principle расширяется интерфейсом Authentication.
	• Кастинг полученного объекта для получения UserDetails.
3. Получение через аннотацию @Principal
	• Использование аннотации @Principal для внедрения UserDetails без кастов.
	• Аннотации извлекают UserDetails из контекста безопасности.
4. Получение пользовательских данных в функциональном обработчике
	• Реализация логики в функциональном обработчике HTTP-запроса.
	• Получение UserDetails через request.principal.
	• Возврат данных о текущем пользователе.
	• Перезапуск приложения для проверки работы метода.
5. Через указание в качестве аргумента интерфейс Principal

### Точки входа аутентификации
Точки входа аутентификации - Spring Security в деталях

Точка входа — это компонент интерфейса AuthenticationEntryPoint, который направляет пользователя на аутентификацию при попытке доступа к защищённому ресурсу.
• При попытке доступа неаутентифицированным пользователем выбрасывается исключение, которое обрабатывает точка входа.

#### Реализация точки входа

• Для Basic аутентификации точка входа показывает форму для ввода логина и пароля, отправляя ответ со статусом 401 и заголовком WWW-Authenticate.
• Для аутентификации через форму происходит перенаправление на страницу логина со статусом 302.

#### Интерфейс AuthenticationEntryPoint

• Интерфейс содержит метод authenticate, который принимает три аргумента: запрос, ответ и исключение аутентификации.
• В ответе добавляются заголовки и содержимое для указания необходимости аутентификации.

#### Глобальная точка входа

• Для перенаправления пользователя в случае ошибки доступа требуется глобальная точка входа.
• При отсутствии других точек входа Spring Security использует стандартную точку входа HTTP 403.

#### Переопределение точки входа

• Переопределение точки входа возможно через DSL Exception Handling.
• Можно указать собственную точку входа, используя лямбда-выражение.

#### Конфигурация точек входа

• Точки входа могут быть сконфигурированы глобально или в конкретных фильтрах.
• У Form-based аутентификации нет собственной точки входа, в отличие от Basic аутентификации.
• Точка входа в фильтре нужна для повторного отображения окна аутентификации при ошибке.

#### Логирование ошибок

• Точка входа может использоваться для логирования ошибок.
• Вывод трассировки помогает понять, что пошло не так.
• Пример: вывод трассировки без добавления блогера для экономии времени.

#### Обработка ошибок точкой входа

• Точка входа перенаправляет пользователя на форму аутентификации и выводит сообщение об ошибке.
• Можно указывать множество точек входа для разных путей и методов.
• Если ни одна из точек входа не смогла обработать ошибку, вызывается точка входа по умолчанию, которая возвращает ошибку 403.




